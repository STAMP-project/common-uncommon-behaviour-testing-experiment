/*
 * This file was automatically generated by EvoSuite
 * Mon Nov 04 13:11:19 GMT 2019
 */

package weka.filters.unsupervised.attribute;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.ArrayList;
import java.util.Enumeration;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import weka.core.AbstractInstance;
import weka.core.Attribute;
import weka.core.DenseInstance;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Range;
import weka.core.TestInstances;
import weka.filters.Filter;
import weka.filters.MultiFilter;
import weka.filters.unsupervised.attribute.PartitionedMultiFilter;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class PartitionedMultiFilter_ESTest extends PartitionedMultiFilter_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      Instances instances0 = new Instances(";*;A=P~@\"6XG; RK7", arrayList0, 4257);
      assertNotNull(instances0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(";*;A=P~@\"6XG; RK7", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numAttributes());
      
      Attribute attribute0 = new Attribute("@data", 4257);
      assertNotNull(attribute0);
      assertTrue(attribute0.hasZeropoint());
      assertTrue(attribute0.isRegular());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNumeric());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isString());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertEquals(4257, attribute0.index());
      assertTrue(attribute0.isAveragable());
      assertEquals("@data", attribute0.name());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertTrue(attribute0.hasZeropoint());
      assertTrue(attribute0.isRegular());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNumeric());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isString());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertEquals(4257, attribute0.index());
      assertTrue(attribute0.isAveragable());
      assertEquals("@data", attribute0.name());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertTrue(boolean0);
      
      boolean boolean1 = arrayList0.add(attribute0);
      assertTrue(boolean1 == boolean0);
      assertTrue(arrayList0.contains(attribute0));
      assertEquals(2, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertTrue(attribute0.hasZeropoint());
      assertTrue(attribute0.isRegular());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(0, attribute0.type());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNumeric());
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isString());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertEquals(4257, attribute0.index());
      assertTrue(attribute0.isAveragable());
      assertEquals("@data", attribute0.name());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertTrue(boolean1);
      
      // Undeclared exception!
      try { 
        partitionedMultiFilter0.process(instances0);
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // weka/core/WekaPackageManager
         //
         verifyException("weka.core.Utils", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      Instances instances0 = new Instances(";*;A=P~@\"6XG; RK7", arrayList0, 4257);
      assertNotNull(instances0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(";*;A=P~@\"6XG; RK7", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      
      partitionedMultiFilter0.determineUnusedIndices(instances0);
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(";*;A=P~@\"6XG; RK7", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      
      partitionedMultiFilter0.checkDimensions();
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      TestInstances testInstances0 = new TestInstances();
      assertNotNull(testInstances0);
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      
      Instances instances0 = testInstances0.generate();
      assertNotNull(instances0);
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals(2, instances0.numClasses());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertEquals(20, instances0.size());
      assertEquals(20, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      
      double[] doubleArray0 = new double[5];
      DenseInstance denseInstance0 = new DenseInstance((-1149.9), doubleArray0);
      assertNotNull(denseInstance0);
      assertEquals((-1149.9), denseInstance0.weight(), 0.01);
      assertEquals(5, denseInstance0.numValues());
      assertEquals(5, denseInstance0.numAttributes());
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      assertEquals(5, doubleArray0.length);
      assertArrayEquals(new double[] {0.0, 0.0, 0.0, 0.0, 0.0}, doubleArray0, 0.01);
      
      boolean boolean0 = instances0.add((Instance) denseInstance0);
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, instances0.numAttributes());
      assertEquals(2, instances0.numClasses());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertEquals((-1129.9), instances0.sumOfWeights(), 0.01);
      assertEquals(21, instances0.size());
      assertEquals(21, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1149.9), denseInstance0.weight(), 0.01);
      assertEquals(5, denseInstance0.numValues());
      assertEquals(5, denseInstance0.numAttributes());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      assertEquals(5, doubleArray0.length);
      assertTrue(boolean0);
      assertArrayEquals(new double[] {0.0, 0.0, 0.0, 0.0, 0.0}, doubleArray0, 0.01);
      
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      
      Instances instances1 = partitionedMultiFilter0.renameAttributes(instances0, ".arff");
      assertFalse(instances1.equals((Object)instances0));
      assertNotNull(instances1);
      assertNotSame(instances0, instances1);
      assertNotSame(instances1, instances0);
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, instances0.numAttributes());
      assertEquals(2, instances0.numClasses());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertEquals((-1129.9), instances0.sumOfWeights(), 0.01);
      assertEquals(21, instances0.size());
      assertEquals(21, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals(21, instances1.size());
      assertEquals(2, instances1.numClasses());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals((-1129.9), instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertEquals("Testdata", instances1.relationName());
      assertEquals(21, instances1.numInstances());
      assertEquals(1, instances1.classIndex());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      
      partitionedMultiFilter0.m_RemoveUnused = true;
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertTrue(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      
      boolean boolean0 = partitionedMultiFilter0.getRemoveUnused();
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertTrue(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      
      Range[] rangeArray0 = new Range[0];
      partitionedMultiFilter0.m_Ranges = rangeArray0;
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      
      Range[] rangeArray1 = partitionedMultiFilter0.getRanges();
      assertNotNull(rangeArray1);
      assertSame(rangeArray1, rangeArray0);
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals(0, rangeArray1.length);
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      
      Range range0 = partitionedMultiFilter0.getRange(0);
      assertNotNull(range0);
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(range0.getInvert());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      
      Filter[] filterArray0 = new Filter[0];
      partitionedMultiFilter0.setFilters(filterArray0);
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals(0, filterArray0.length);
      
      Filter[] filterArray1 = partitionedMultiFilter0.getFilters();
      assertNotNull(filterArray1);
      assertSame(filterArray1, filterArray0);
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals(0, filterArray1.length);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      
      Filter[] filterArray0 = new Filter[3];
      filterArray0[1] = (Filter) partitionedMultiFilter0;
      partitionedMultiFilter0.setFilters(filterArray0);
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals(3, filterArray0.length);
      
      PartitionedMultiFilter partitionedMultiFilter1 = (PartitionedMultiFilter)partitionedMultiFilter0.getFilter(1);
      assertNotNull(partitionedMultiFilter1);
      assertSame(partitionedMultiFilter0, partitionedMultiFilter1);
      assertSame(partitionedMultiFilter1, partitionedMultiFilter0);
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter1.isOutputFormatDefined());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter1.globalInfo());
      assertFalse(partitionedMultiFilter1.getDebug());
      assertFalse(partitionedMultiFilter1.isFirstBatchDone());
      assertEquals("The base filters to be used.", partitionedMultiFilter1.filtersTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter1.debugTipText());
      assertFalse(partitionedMultiFilter1.getRemoveUnused());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter1.rangesTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter1.removeUnusedTipText());
      assertFalse(partitionedMultiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter1.isNewBatch());
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      Instances instances0 = new Instances("{olQeP.1&,yN8,o5E", arrayList0, 25);
      assertNotNull(instances0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("{olQeP.1&,yN8,o5E", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      
      try { 
        partitionedMultiFilter0.testInputFormat(instances0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // No upper limit has been specified for range
         //
         verifyException("weka.core.Range", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      
      try { 
        partitionedMultiFilter0.testInputFormat((Instances) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.Instances", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      
      String[] stringArray0 = new String[4];
      stringArray0[0] = "{olQeP.1&,yN8,o5E";
      stringArray0[1] = "{olQeP.1&,yN8,o5E";
      stringArray0[2] = "{olQeP.1&,yN8,o5E";
      stringArray0[3] = "-";
      try { 
        partitionedMultiFilter0.setOptions(stringArray0);
        fail("Expecting exception: StringIndexOutOfBoundsException");
      
      } catch(StringIndexOutOfBoundsException e) {
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      
      String[] stringArray0 = new String[4];
      try { 
        partitionedMultiFilter0.setOptions(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.Utils", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.getDebug());
      
      String[] stringArray0 = new String[1];
      stringArray0[0] = "-R";
      try { 
        partitionedMultiFilter0.setOptions(stringArray0);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // No value given for -R option.
         //
         verifyException("weka.core.Utils", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      
      try { 
        partitionedMultiFilter0.renameAttributes((Instances) null, "@relation");
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.unsupervised.attribute.PartitionedMultiFilter", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      
      try { 
        partitionedMultiFilter0.process((Instances) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.unsupervised.attribute.PartitionedMultiFilter", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      Instances instances0 = new Instances("{olQeP.1&,yN8,o5E", arrayList0, 0);
      assertNotNull(instances0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numAttributes());
      assertEquals("{olQeP.1&,yN8,o5E", instances0.relationName());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      
      Range[] rangeArray0 = new Range[0];
      partitionedMultiFilter0.m_Ranges = rangeArray0;
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      
      try { 
        partitionedMultiFilter0.process(instances0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Number of filters (= 1) and ranges (= 0) don't match!
         //
         verifyException("weka.filters.unsupervised.attribute.PartitionedMultiFilter", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      
      partitionedMultiFilter0.m_Ranges = null;
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      
      // Undeclared exception!
      try { 
        partitionedMultiFilter0.getOptions();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.unsupervised.attribute.PartitionedMultiFilter", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      
      Range range0 = new Range();
      assertNotNull(range0);
      assertFalse(range0.getInvert());
      
      try { 
        partitionedMultiFilter0.generateSubset((Instances) null, range0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // No upper limit has been specified for range
         //
         verifyException("weka.core.Range", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      
      TestInstances testInstances0 = new TestInstances();
      assertNotNull(testInstances0);
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      
      Instances instances0 = testInstances0.generate();
      assertNotNull(instances0);
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numClasses());
      assertEquals(20, instances0.size());
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, instances0.classIndex());
      assertEquals("Testdata", instances0.relationName());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      
      try { 
        partitionedMultiFilter0.generateSubset(instances0, (Range) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.unsupervised.attribute.PartitionedMultiFilter", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      TestInstances testInstances0 = new TestInstances();
      assertNotNull(testInstances0);
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumString());
      assertFalse(testInstances0.getNoClass());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getClassType());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(1, testInstances0.getSeed());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      
      Instances instances0 = testInstances0.generate();
      assertNotNull(instances0);
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumString());
      assertFalse(testInstances0.getNoClass());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getClassType());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals(20, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(20, instances0.size());
      assertEquals(1, instances0.classIndex());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(2, instances0.numClasses());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      
      // Undeclared exception!
      try { 
        partitionedMultiFilter0.determineUnusedIndices(instances0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // No upper limit has been specified for range
         //
         verifyException("weka.core.Range", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      
      // Undeclared exception!
      try { 
        partitionedMultiFilter0.determineUnusedIndices((Instances) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.unsupervised.attribute.PartitionedMultiFilter", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      
      try { 
        partitionedMultiFilter0.determineOutputFormat((Instances) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.unsupervised.attribute.PartitionedMultiFilter", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.getDebug());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      String string0 = partitionedMultiFilter0.getFilterSpec(multiFilter0);
      assertNotNull(string0);
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.getDebug());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("weka.filters.MultiFilter -F weka.filters.AllFilter", string0);
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      
      partitionedMultiFilter0.setOptions((String[]) null);
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      
      Enumeration enumeration0 = partitionedMultiFilter0.listOptions();
      assertNotNull(enumeration0);
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      
      boolean boolean0 = partitionedMultiFilter0.getRemoveUnused();
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      PartitionedMultiFilter partitionedMultiFilter0 = new PartitionedMultiFilter();
      assertNotNull(partitionedMultiFilter0);
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      
      Range[] rangeArray0 = partitionedMultiFilter0.getRanges();
      assertNotNull(rangeArray0);
      assertFalse(partitionedMultiFilter0.getDebug());
      assertEquals("Turns on output of debugging information.", partitionedMultiFilter0.debugTipText());
      assertFalse(partitionedMultiFilter0.isFirstBatchDone());
      assertEquals("If true then unused attributes (ones that are not covered by any of the ranges) will be removed from the output.", partitionedMultiFilter0.removeUnusedTipText());
      assertFalse(partitionedMultiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(partitionedMultiFilter0.isNewBatch());
      assertFalse(partitionedMultiFilter0.getRemoveUnused());
      assertEquals("A filter that applies filters on subsets of attributes and assembles the output into a new dataset. Attributes that are not covered by any of the ranges can be either retained or removed from the output.", partitionedMultiFilter0.globalInfo());
      assertEquals("The attribute ranges to be used; 'inv(...)' denotes an inverted range.", partitionedMultiFilter0.rangesTipText());
      assertFalse(partitionedMultiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", partitionedMultiFilter0.filtersTipText());
      assertEquals(1, rangeArray0.length);
  }
}
